'use strict';

var react = require('react');

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

var useLoadMoreOnScroll = function useLoadMoreOnScroll(props) {
    var _props$fetchSize = props.fetchSize,
        fetchSize = _props$fetchSize === undefined ? 10 : _props$fetchSize,
        _props$limit = props.limit,
        limit = _props$limit === undefined ? 500 : _props$limit,
        scroller = props.scroller,
        _props$mode = props.mode,
        mode = _props$mode === undefined ? 'error' : _props$mode,
        _props$minDelta = props.minDelta,
        minDelta = _props$minDelta === undefined ? 25 : _props$minDelta;

    if (!scroller) throw new Error('Cannot use useLoadMoreOnScroll without specifying a scroller. \n scroller MUST be an HtmlDOMElement acquired via useRef() or React.ref()');
    var l = function l() {};
    if (mode === 'debug') {
        l = console.log;
    }

    var _useState = react.useState(fetchSize),
        _useState2 = slicedToArray(_useState, 2),
        lastFetchSize = _useState2[0],
        setLastFetchSize = _useState2[1];

    var _useState3 = react.useState(999),
        _useState4 = slicedToArray(_useState3, 2),
        delta = _useState4[0],
        setDelta = _useState4[1];

    var _useState5 = react.useState(0),
        _useState6 = slicedToArray(_useState5, 2),
        scrollTop = _useState6[0],
        setScrollTop = _useState6[1];

    var _useState7 = react.useState('none'),
        _useState8 = slicedToArray(_useState7, 2),
        scrollDirection = _useState8[0],
        setScrollDirection = _useState8[1];

    var _useState9 = react.useState(false),
        _useState10 = slicedToArray(_useState9, 2),
        doneFetching = _useState10[0],
        setDoneFetching = _useState10[1];

    var _useState11 = react.useState(true),
        _useState12 = slicedToArray(_useState11, 2),
        isFetching = _useState12[0],
        setIsFetching = _useState12[1];

    var _useState13 = react.useState(false),
        _useState14 = slicedToArray(_useState13, 2),
        hasScrollbar = _useState14[0],
        setHasScrollbar = _useState14[1];

    var _useState15 = react.useState(0),
        _useState16 = slicedToArray(_useState15, 2),
        initFetchCount = _useState16[0],
        setInitFetchCount = _useState16[1];

    var _useState17 = react.useState(0),
        _useState18 = slicedToArray(_useState17, 2),
        lastCount = _useState18[0],
        setLastCount = _useState18[1];

    var _useState19 = react.useState(0),
        _useState20 = slicedToArray(_useState19, 2),
        start = _useState20[0],
        setStart = _useState20[1];

    var _useState21 = react.useState(0),
        _useState22 = slicedToArray(_useState21, 2),
        end = _useState22[0],
        setEnd = _useState22[1];

    react.useEffect(function () {
        if (!isFetching && !hasScrollbar && lastCount !== initFetchCount && !doneFetching) {
            l('Trying to  make the scrollbar visible : ' + initFetchCount);
            setLastFetchSize(lastFetchSize + fetchSize);
        }
        setLastCount(initFetchCount);
    }, [initFetchCount, isFetching, hasScrollbar, lastFetchSize, fetchSize, doneFetching]);

    react.useEffect(function () {
        if (!hasScrollbar && !isFetching) {
            setInitFetchCount(initFetchCount + 1);
        }
    }, [isFetching, hasScrollbar]);

    react.useEffect(function () {
        var scrollElement = scroller.current;
        setHasScrollbar(scrollElement.scrollHeight > scrollElement.getBoundingClientRect().height);
    }, [isFetching]);

    react.useEffect(function () {
        var scrollElement = scroller.current;
        var previousScroll = 0;
        l('scroll listener added to element', scrollElement);
        var scrollHandler = scrollElement.addEventListener("scroll", function (e) {
            setScrollTop(scrollElement.scrollTop);
            if (previousScroll < scrollElement.scrollTop) {
                setScrollDirection("down");
            } else {
                setScrollDirection("up");
            }
            previousScroll = scrollElement.scrollTop;
        });
        return function () {
            l('scroll listener removed from element', scrollElement);
            scrollElement.removeEventListener("scroll", scrollHandler);
        };
    }, [scroller]);

    react.useEffect(function () {
        var scrollElement = scroller.current;
        if (scrollDirection === "down") {
            setDelta(scrollElement.scrollHeight - scrollElement.scrollTop - scrollElement.getBoundingClientRect().height);
        }
    }, [scrollTop, scrollDirection, isFetching]);

    react.useEffect(function () {
        l('delta value ' + delta + ' and scroll direction ' + scrollDirection);
        if (delta <= minDelta && !isFetching && !doneFetching) {
            setLastFetchSize(lastFetchSize + fetchSize);
        }
    }, [delta, doneFetching]);

    react.useEffect(function () {
        if (lastFetchSize <= limit) {
            if (lastFetchSize - fetchSize !== lastFetchSize) {
                setStart(lastFetchSize - fetchSize);
                setEnd(lastFetchSize);
                l('Requesting fetch for start ' + start + ' end ' + end);
            }
        } else if (limit - lastFetchSize + fetchSize > 0 && limit - lastFetchSize <= fetchSize) {
            setStart(lastFetchSize - fetchSize);
            setEnd(limit);
            l('Requesting fetch for start ' + start + ' end ' + end);
        } else {
            l('Reached max limit set ' + limit);
            setDoneFetching(true);
        }
    }, [lastFetchSize, limit, fetchSize]);
    var forceDonefetching = function forceDonefetching() {
        l('User requested stop fetching');
        setDoneFetching(true);
    };
    return {
        start: start,
        end: end,
        isFetching: isFetching,
        doneFetching: doneFetching,
        setIsFetching: setIsFetching,
        forceDonefetching: forceDonefetching
    };
};

module.exports = useLoadMoreOnScroll;
//# sourceMappingURL=index.js.map
